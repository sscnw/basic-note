##1. ``String s = new String("xyz");`` 创建了几个StringObject？是否可以继承String
两个或者一个都有可能，`'xyz'`对应一个对象，这个对象放在字符串常量缓冲区，常量`xyz`不管出现多少遍，都是缓冲区的哪一个。new一次就创建一个新的对象。使用常量`xyz`创建的，如果以前用过，那就不会再创建`xyz`了，直接从缓存区拿，这时创建了一个StringObject，如果没用过，就会创建一个`xyz`，这种情况是创建两个对象。至于String是否被继承，不可以的String默认final修饰，不可继承
##2.`` String s="a"+"b"+"c"+"d";``一共创建了多少个对象
```
String s1="a";
Stirng s2=s1+"b";
String s3="a"+"b";
System.out.println(s2=="ab");
System.out.println(s3=="ab");
```
第一句false，第二句true。javac编译可以对字符串常量相加直接的表达式进行优化，不必等到运行期处理，编译时直接去掉其中的加号，将其编译程一个这些常量相连的结果。
所以题目上就是直接定义了一个abcd，一个对象
## 3. try{}里有一个return，finally的语句怎么执行
语句是执行的，在return之间
```
public class Test{
public  static void main(String[] args){
	System.out.println(new Test().test());
}
static int test(){
	int x=1;
	try{
	return x;
	}
	finally{
	++x;
	}
}
}
```
执行结果是1,住函数准备一个空罐子，当子函数返回结果时，先把结果放在罐子里，然后再将程序逻辑返回到主函数，就是子函数说，我不运行了，主函数继续运行把
## 4. final,finally,finalize的区别
finall=用于声明属性，方法和类，表示属性不可变，方法不可覆盖，类不可继承，内部类要访问局部变量，局部变量必须是final类型
finalize是object的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾挥手时的其他资源挥手，例如关闭文件。

##5. error和exception有什么区别
error表示回复不是不可能但很困难的情况的严重问题，如内存溢出，不可能指望程序能处理这样的情况。exception表示一种设计或实现问题。也就是说，如果程序运行正常，就不会发生这样的情况
##6. Java 中的异常处理机制的简单原理和应用
异常是指java程序运行时（非编译）所发生的非正常情况或错误。每个异常分别封装到一个对象来表示。
根是java.lang.Throwable,下边有Error和exception，error内存溢出或者线程死锁等问题
Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常：系统异常是软件本身缺陷所导致的问题。也就是软件开发人员考虑不周所导致的问题，如数组越界，空指针异常，类型转换异常
普通异常指的是运行环境变化或异常导致的问题，是用户能够克服的，如网线断了，硬盘不够。
普通异常必须try catch 称为checed异常，系统异常可以处理可以不处理，unchecked
##7. Java中堆和栈的区别
JVM中堆和栈属于不同的内存区域，使用目的也不同。栈通常用于保存方法帧和局部变量，而对象总是在堆上分配，栈通常都比堆小，也不会在多个线程之间共享，而堆被整个JVM的索引线程共享
栈：在函数中的定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java就会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用
堆：用来存放由new创建的对象和数组，在堆中分配内存，由java虚拟机的自动垃圾回收器来管理，在堆中产生了数组或者对象后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于其在堆中的首地址，栈中的这个变量就变成了引用变量，以后就可以用栈中的引用变量来访问堆中的数组或者对象。
##8. int强转byte
int32位，byte8位，int的高24位会被丢弃 （-128-127）
##9. a.hashCode() 和equals()
hashCode() 方法对应对象整型的hash值，它常用于基于hash的集合类，如hashtable，hashmap，linkedhashmap等等两个使用equal()方法判断相等的对象，必须具有相同的hashcode
##字节流与字符流的区别
要把一段二进制数据逐一输出到某个设备中，或者从某个设备中逐一读取一段二进制数，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式描述，就是IO流。对应的抽象类	OutputStream和InputStream，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。
计算机中的一切最终都是二进制的字节形式存在，对于常用到的中文字符，首先要得到其对应的字节，然后将字节写入到输入输出流，读取时，首先读到的是字节，然后转化为字符，于是java提供了字符流包装类
底层设备pyongyang只接收字节数据，有时候要写字符串到底层设备，需要将字符串转程字节再进行写入，字符流是字节流的包装，字符流直接接收字符串，它内部将串转成该字符的某种编码的字节形式，读取也是反之的道理
##什么是java序列化，如何实现java序列化，请解释Serializable接口的作用
我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复程一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流传输。
但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java帮我们做，要被传输的对象必须实现serializable接口，这样javac编译时就会进行特殊处理，编译类才可以被writeObject方法操作，这就是所谓的序列化，需要被序列化的类必须实现这个接口，这个接口是一个mini接口，其中没有需要实现的方法，只是为了标注该对象是可被序列化的。
例如，在web开发中，如果对喜爱嗯被保存在了Session中，tomcat在重启时要把Session对象序列化到硬盘，这个对象就必须实现Serializable接口，如果对象要经过分布式系统进行网络传输，传输的对象就必须实现接口
##JVM加载class文件的原理机制
JVM中类的装载是由ClassLoader和它的子类来实现的，hjava classloader 是一个重要的java运行时系统组件，它负责在运行时查找和装入类文件的类
##heap和stack有什么区别
java的内存分为两类，一类是栈内存，一类时堆内存，栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也会随之释放
堆是与栈作用不同的内存，一般用于存放不再当前方法栈中的那些数据。例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失，方法中的局部变量使用final修饰后，放在堆中
##GC是什么
GC垃圾收集的意思Gabage Collection 内存处理是编程人员容易出现问题的地方GC可以自动检测对象是否超过作用域从而达到自动挥手内存的目的，java语言没有提供释放已分配内存的显示操作办法
##垃圾回收的优点和原理
由于垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有作用域
垃圾挥手可以有效防止内存泄漏，有效的使用可以使用的内存，垃圾回收通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾挥手器对某个对象或所有对象进行垃圾挥手
回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。
##垃圾回收的基本原理是什么，GC可以马上回收内存吗，有什么办法主动通知虚拟机进行垃圾回收
对于GC来说，当程序员创建对下该时，GC就开始监控这个对下该的地址，大小以及使用情况。通常，GC采用有向图的方式记录和管理heap堆中的所有对象。通过这种方式确定哪些对象是可达的，哪些对象是不可打的，确定不可达时，GC就有责任去回收内容啦。
程序员可以手动执行System.GC通知GC运行，但是java语言规范并不保证GC一定会执行
## throw和throws区别
throw用于抛出java.lang.Throwable类的一个实例化对象如``throw new Exceptino(" ")``而throws是作为方法声明和签名的一部分，java中，任何未处理的受检查一查该强制在throws子句中声明
##java中会存在内存泄漏吗，请简单描述
什么是内存泄漏：就是指一个不再被程序使用的对象或变量一直被占据在内存中，java中有垃圾回收机制，它可以保证当对象不再被引用的时候，对象将自动被垃圾回收器从内存中清除掉
由于java使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达，那么GC也是可以回收它们的
java中的内存泄漏的情况：畅声明周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是内存泄漏的场景。通俗的将，程序员可能创建了一个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收时，就是内存泄漏。例如，缓存系统，我们加载了一个对象放在缓存中（例如放在一个全局的map对象中），然后一直不再使用它，这个对象一直被缓存引用，但是却不再白使用。